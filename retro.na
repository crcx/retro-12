( Retro ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( Copyright [c] 2008 - 2014, Charles Childers                                 )
( Copyright [c] 2009 - 2010, Luke Parrish                                     )
( Copyright [c] 2010,        Marc Simpson                                     )
( Copyright [c] 2010,        Jay Skeer                                        )
( Copyright [c] 2012,        Michal J Wallace                                 )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )

include ngaro-asm.rx
devector keymap:handler

beginApplication

label: last      0 ,
label: heap      0 ,
label: compiler  0 ,
label: which     0 ,

label: memory    0 ,
label: fb        0 ,
label: fw        0 ,
label: fh        0 ,
label: cw        0 ,
label: ch        0 ,

label: copytag   "Retro" $,
label: version   "11.6" $,
label: build     "2014.04.01" $,
label: okmsg     "ok  " $,

label: comma
  heap # @, dup, 1+, push, !, pop, heap # !,
  return,

label: withClass
  1-, push,
  return,

label: .word
  compiler # @, 0 # !if call: comma return, then jump: withClass

label: .macro
  jump: withClass

label: .data
  compiler # @, 0;, drop, 1 # call: comma call: comma
  return,

label: .primitive  (  a- )
    dup, @, 0 # =if compiler # @, -1 # =if 2 # +, @, then then jump: .word

label: dup
  dup,
  return,

label: 1+
  1+,
  return,

label: 1-
  1-,
  return,

label: swap
  swap,
  return,

label: drop
  drop,
  return,

label: and
  and,
  return,

label: or
  or,
  return,

label: xor
  xor,
  return,

label: @
  @,
  return,

label: !
  !,
  return,

label: +
  +,
  return,

label: -
  -,
  return,

label: *
  *,
  return,

label: /mod
  /mod,
  return,

label: <<
  <<,
  return,

label: >>
  >>,
  return,

label: out
  out,
  return,

label: in
  in,
  return,

label: wait
  0 # 0 # out, wait,
  return,

label: over
  push, dup, pop, swap,
  return,

label: not
  -1 # xor,
  return,

label: on
  -1 # swap, !,
  return,

label: off
  0 # swap, !,
  return,

label: /
  /mod, swap, drop,
  return,

label: mod
  /mod, drop,
  return,

label: negate
  -1 # *,
  return,

label: do
  1-, push,
  return,

label: @+
  dup, 1+, swap, @,
  return,

label: !+
  dup, 1+, push, !, pop,
  return,

label: here
  heap # @,
  return,

label: ;;
  9 # call: comma
  return,

label: ;
  call: ;;
  compiler #
  call: off
  return,

label: ($,)
  REPEAT
    call: @+
    0;,
    call: comma
  AGAIN
  return,

label: $
  drop, 0 # call: comma
  return,

label: push
  5 # call: comma
  return,

label: pop
  6 # call: comma
  return,

label: 0;
  25 # call: comma
  return,

label: repeat
  call: here
  return,

label: again
  8 #
  call: comma
  call: comma
  return,

label: update
  -1 ,

label: redraw
  update # @, 0;, drop, 0 # 3 # out,
  return,

label: putc
  0;, 1 # 2 # out,
  call: wait
  call: redraw
  return,

label: cr
  10 #
  call: putc
  return,

label: (puts)
  REPEAT
    call: @+
    0;,
    call: putc
  AGAIN
  return,

label: <puts>
  call: (puts)
  drop,
  return,

label: puts
  call: <puts>
  return,

label: break
  0 ,

label: remapping
  -1 ,

label: eatLeading?
  -1 ,

label: tabAsWhitespace
  -1 ,

label: keymap
  0 ,

label: keymap:PREFIX
  9 ,

label: keymap:TABLE
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,

label: STRING-LENGTH
  256 #
  return,

label: STRING-BUFFERS
  12 #
  return,

label: tib
  memory #
  @,
  call: STRING-LENGTH
  -,
  return,

label: remapKeys
  return,

label: remap:whitespace
   dup,  127 # =if drop,  8 # then
   dup,   13 # =if drop, 10 # then
   remapping # @, 0;, drop,
   dup,   10 # =if drop, 32 # then
   tabAsWhitespace # @, 0;, drop, dup, 9 # =if drop, 32 # then
   return,

label: getc:unfiltered
   1 # 1 # out,
   call: wait
   1 # in,
   return,

label: getc:with/remap
  REPEAT
    call: getc:unfiltered
    call: remapKeys
    dup, 0 # !if call: remap:whitespace return, then
    drop,
  AGAIN
  return,

label: keymap:handler
  return,

label: getc getc
  REPEAT
    call: getc:unfiltered
    call: keymap:handler
    call: remapKeys
    dup, 0 # !if call: remap:whitespace return, then drop,
  AGAIN
  return,


label: putc?
  dup,
  8 # =if drop, break # @, return, then dup, call: putc return,


label: eat
   eatLeading? # @, 0;, drop,
   REPEAT
     call: getc
     call: putc?
     dup,
     break # @,
     !if swap, call: !+ return, then
     drop,
  AGAIN
  return,

label: guard?
  dup,
  1+,
  call: tib
  <if drop, call: tib return, then 8 # call: putc
  return,

label: (accept)
   REPEAT
     call: getc
     dup, 8 # =if drop, 1-, guard? jump: (accept) then
     dup,
     call: putc
     dup, break # @, =if drop, return, then
     swap,
     call: !+
   AGAIN return,

label: accept
  break # !,
  call: tib
  call: eat
  call: (accept)
  0 #
  swap,
  call: !+
  drop,
  return,

label: vector
  -1 ,

label: d->class
  1+,
  return,

label: d->xt
  1+, 1+,
  return,

label: d->doc
  3 # +,
  return,

label: d->name
  4 # +,
  return,

label: header
  push,
  call: here        ( Entry Start      )
  last # @,         ( Link to previous )
  call: comma
  last # !,         ( Set as newest    )
  .data #           ( Class = .data    )
  call: comma
  call: here
  0 #               ( XT               )
  call: comma
  0 #               ( Pointer to docstr)
  call: comma
  pop,
  call: $           ( Name             )
  call: here
  swap, !, return,  ( Patch XT to HERE )

label: create
  32 #
  call: accept
  call: tib
  call: header
  return,

label: [[
  compiler #
  call: off
  return,

label: ]]
  compiler #
  call: on
  return,

label: vector?
  vector # @,
  0;, drop,
  0 #
  call: comma
  0 #
  call: comma
  return,

label: :
  call: create
  .word #
  last #
  @,
  call: d->class
  !,
  call: ]]
  call: vector?
  return,

label: t-(
  ') #
  call: accept
  return,


( main setEntryPoint )
"retroImage" saveImageAs
.s
bye










( Colon Compiler ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )

( Quotes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )

( reference diagram:                                           )
(                                                              )
(  step       generated code.                                  )
(  -------    ----------------                                 )
(  [          <quote> 0000                                     )
(  [ 5        <quote> 0000 <lit> 0005                          )
(  [ 5 ]      <quote> ADDR <lit> 0005 <ret>                    )
(                                                              )
( ADDR will be same as "here" immediately after compilation    )
(                                                              )
( <quote> is the xt for "quote" - 711 as of retro 11.5 . This  )
( changes with kernel/meta.rx but the number should always be  )
( the same as both:  ' quote     and:  d' quote @d->xt         )

label: quote quote ( -a  ) ( -- runtime -------------------------------- )
  pop, 1+        (   -a  | grab the return address, add 1, and )
  dup,           (  a-aa | dup, giving two pointers to ADDR    )
  @,             ( aa-aA | dereference one for actual target   )
  1-,            ( aa-aA | subtract 1 because ip++ in ngaro vm )
  push,          ( aA-a  | push result to do a calculated jump )
  1+, return,          (  a-a  | point to start of code, jump to end )

m: [ [ ( -a )      ( -- compile-time---------------------------- )
  ' quote # ,    (   -   | compile a call to quote             )
  here           (   -a  | remember where to put ADDR          )
  0 # ,          (  a-a  | leave a cell to hold it later       )
  compiler # @,  (  a-af | store current compiler state        )
  compiler # on  ( af-af | turn the compiler on                )
  return,

m: ] ] ( af- ) ( a = placeholder for quote jump, f = old compile state  )
   ;;            ( af-af | compile a return from quoted code   )
   compiler # !, ( af-a  | restore compiler state              )
   here          (  a-aA | now we know what ADDR should be     )
   over !,       ( aA-a  | so go replace the 00                )
   compiler # @, (  a-af | recall current compile state        )
   0 # =if       ( af-a  | are we outside of the compiler?     )
                 ( -- runtime -------------------------------- )
     1+, return,       (  a-a  | for interactive, keep ptr to start  )
                 ( -- compile-time---------------------------- )
   then drop, return,  (  a-   | inside compile mode, just discard.  )
                 (       | the call to 'quote will restore it  )
                 (       | when the containing function runs   )

( Combinators ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
i: empty return,
( [ - ] internal helper corresponding to an empty quote )

label: if if push, swap, pop, swap, 0 # !if drop, do return, then swap, drop, do return,

label: ifTrue ifTrue   ' empty # if return,

label: ifFalse ifFalse ' empty # swap, if return,

label: dip dip swap, push, do pop, return,

label: sip sip over ' do # dip return,

( Conditionals ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
i: false (  -n  )  0 # return,
( [ -f ] helper, returns 0 for false )

i: true  (  -n  ) -1 # return,
( [ -f ] helper, returns -1 for true )

label: =  =  ( xy-f  ) =if jump: true  then jump: false

label: == == = return,

label: <> <>  ( xy-f  ) !if jump: true  then jump: false

label: != != <> return,

label: >= >=  ( xy-f  ) >if jump: true  then jump: false

label: <= <=  ( xy-f  ) <if jump: true  then jump: false

label: < <    ( xy-f  ) >if jump: false then jump: true

label: > >    ( xy-f  ) <if jump: false then jump: true

( Strings ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
label: compare compare
   REPEAT
     dup, @, push, 1+, swap,
     dup, @, push, 1+, pop, dup, pop,
     !if drop, drop, dup, xor, return, then
   0 # 12 m, m,
   drop, drop, -1 # return,

i: count REPEAT @+ 0;, drop, AGAIN return,
( [ a-a ] internal helper for getting string length )

label: getLength getLength   ( a-n ) dup, count 1-, swap, -, return,

label: withLength withLength  ( a-an ) dup, getLength return,

label: string string      ( -   ) pop, count 1-, push, return,

label: keepString keepString  ( a-a ) ' string # , here swap, $ return,

label: :devector :devector ( a-  ) 0 # swap, !+ 0 # swap !, return,

label: :is :is      ( aa- ) 8 # swap, !+ !, return,

label: atib atib memory # @, STRING-LENGTH 2 # * - return,

label: " t-" ' atib # ' tib # :is '" # accept ' tib # :devector atib return,

( Numbers [Parsing & Display] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
4 elements #value num negate? flag

10 variable: base

label: numbers "0123456789ABCDEF" $,

label: numbers nums     ( -a ) numbers # return,

i: @base    ( -n ) base # @, return,
( [ -n ] helper function, returns value stored in **base** )

i: (digits) nums +, @, over =if num # on then return,
( NEEDS-DESCRIPTION )

i: digits   1-, REPEAT dup, push, (digits) pop, 0;, 1-, AGAIN return,
( NEEDS-DESCRIPTION )

i: valid?   @base dup, 16 # <if digits return, then drop, return,
( NEEDS-DESCRIPTION )

i: digit?   num # off valid? drop, num # @, return,
( NEEDS-DESCRIPTION )

i: toDigit  ( c-n ) '0 # -, @base 16 # =if dup, 16 # >if 7 # -, then then return,
( NEEDS-DESCRIPTION )

i: isNegative? ( a-a )
   dup, @, '- # =if negate? # on 1+, return, then 1 # negate? # !, return,
( NEEDS-DESCRIPTION )

i: (convert)
   REPEAT
     dup, @, 0;, toDigit #value # @, @base *, +, #value # !, 1+,
   AGAIN return,
( NEEDS-DESCRIPTION )

label: toNumber toNumber ( $-n )
   isNegative? 0 # #value # !, (convert) drop, #value # @, negate? # @, *, return,

i: (isnumber)
   REPEAT dup, @, 0;, digit? flag # @, and, flag # !, 1+, AGAIN return,
( NEEDS-DESCRIPTION )

label: isNumber? isNumber? ( $-f ) isNegative? flag # on (isnumber) drop, flag # @, return,

( Startup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
label: boot boot         (  -  )
   copytag # puts 32 # putc version # puts cr return,

i: query        ( n-n ) 5 # out, wait 5 # in, return,
( NEEDS-DESCRIPTION )

i: run-on-boot  (  -  )
   -1  # query memory # !,  ( Memory Size     )
   -2  # query fb #     !,  ( Canvas Present? )
   -3  # query fw #     !,  ( Canvas Width    )
   -4  # query fh #     !,  ( Canvas Height   )
   -11 # query cw #     !,  ( Console Width   )
   -12 # query ch #     !,  ( Console Height  )
   boot return,
( NEEDS-DESCRIPTION )

( Dictionary Search ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
2 elements name found

i: prepare  ( a-a  ) found # off name # !, last # @, return,
( NEEDS-DESCRIPTION )

i: done     (  -af ) which # @, found # @, return,
( NEEDS-DESCRIPTION )

i: match?   ( $-$f ) dup, d->name name # @, compare return,
( NEEDS-DESCRIPTION )

i: <search> ( $-   )
   REPEAT match? 0 # !if which # !, found # on return, then @ 0;, AGAIN return,
( NEEDS-DESCRIPTION )

label: find find     ( $-af ) prepare <search> done return,

label: ' t-'      ( "-a  ) 32 # accept tib find 0 # !if d->xt @, return, then drop, 0 # return,

( Word Prefixes and "Not Found" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
label: ___   "___" $,

i: get      ( $-$  ) dup, @, ___ # 2 # +, !, 1+, return,
( NEEDS-DESCRIPTION )

i: xt:class ( d-aa ) dup, d->xt @, swap, d->class @, return,
( NEEDS-DESCRIPTION )

i: try      (  -   )
   tib get find 0 #
   !if d->xt @, ___ # find
      0 # !if xt:class withClass 0 # return, then drop,
   then drop, -1 # return,
( NEEDS-DESCRIPTION )

label: <notFound> <notFound> ( -f ) tib getLength 2 # >if try then return,

label: notFound notFound   ( -  ) <notFound> 0;, drop, cr tib puts 32 # putc '? # putc cr return,

( Listener ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
label: ok ok      (   - ) compiler # @, not 0;, drop, cr okmsg # puts return,

i: build#  (   - ) tib toNumber ' .data # jump: withClass
( NEEDS-DESCRIPTION )

i: number  (   - ) tib isNumber? 0 # !if jump: build# then jump: notFound
( NEEDS-DESCRIPTION )

i: process ( af- ) 0 # !if xt:class jump: withClass then drop jump: number
( NEEDS-DESCRIPTION )

label: listen listen  (   - ) REPEAT ok 32 # accept tib find process AGAIN return,

label: save save    (  -  ) 1 # 4 # out, wait return,

label: bye bye      (  -  ) cr -9 # 5 # out, wait return,
