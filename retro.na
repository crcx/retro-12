( Retro ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( Copyright [c] 2008 - 2014, Charles Childers                                 )
( Copyright [c] 2009 - 2010, Luke Parrish                                     )
( Copyright [c] 2010,        Marc Simpson                                     )
( Copyright [c] 2010,        Jay Skeer                                        )
( Copyright [c] 2012,        Michal J Wallace                                 )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )

include ngaro-asm.rx
devector keymap:handler

beginApplication

label: last      0 ,
label: heap      0 ,
label: compiler  0 ,
label: which     0 ,

label: memory    0 ,
label: fb        0 ,
label: fw        0 ,
label: fh        0 ,
label: cw        0 ,
label: ch        0 ,

label: copytag   "Retro" $,
label: version   "11.6" $,
label: build     "2014.04.01" $,
label: okmsg     "ok  " $,

label: comma
  heap # @, dup, 1+, push, !, pop, heap # !,
  return,

label: withClass
  1-, push,
  return,

label: .word
  compiler # @, 0 # !if call: comma return, then jump: withClass

label: .macro
  jump: withClass

label: .data
  compiler # @, 0;, drop, 1 # call: comma call: comma
  return,

label: .primitive  (  a- )
    dup, @, 0 # =if compiler # @, -1 # =if 2 # +, @, then then jump: .word

label: dup
  dup,
  return,

label: 1+
  1+,
  return,

label: 1-
  1-,
  return,

label: swap
  swap,
  return,

label: drop
  drop,
  return,

label: and
  and,
  return,

label: or
  or,
  return,

label: xor
  xor,
  return,

label: @
  @,
  return,

label: !
  !,
  return,

label: +
  +,
  return,

label: -
  -,
  return,

label: *
  *,
  return,

label: /mod
  /mod,
  return,

label: <<
  <<,
  return,

label: >>
  >>,
  return,

label: out
  out,
  return,

label: in
  in,
  return,

label: wait
  0 # 0 # out, wait,
  return,

label: over
  push, dup, pop, swap,
  return,

label: not
  -1 # xor,
  return,

label: on
  -1 # swap, !,
  return,

label: off
  0 # swap, !,
  return,

label: /
  /mod, swap, drop,
  return,

label: mod
  /mod, drop,
  return,

label: negate
  -1 # *,
  return,

label: do
  1-, push,
  return,

label: @+
  dup, 1+, swap, @,
  return,

label: !+
  dup, 1+, push, !, pop,
  return,

label: here
  heap # @,
  return,

label: ;;
  9 # call: comma
  return,

label: ;
  call: ;;
  compiler #
  call: off
  return,

label: ($,)
  REPEAT
    call: @+
    0;,
    call: comma
  AGAIN
  return,

label: $
  drop, 0 # call: comma
  return,

label: push
  5 # call: comma
  return,

label: pop
  6 # call: comma
  return,

label: 0;
  25 # call: comma
  return,

label: repeat
  call: here
  return,

label: again
  8 #
  call: comma
  call: comma
  return,

label: update
  -1 ,

label: redraw
  update # @, 0;, drop, 0 # 3 # out,
  return,

label: putc
  0;, 1 # 2 # out,
  call: wait
  call: redraw
  return,

label: cr
  10 #
  call: putc
  return,

label: (puts)
  REPEAT
    call: @+
    0;,
    call: putc
  AGAIN
  return,

label: <puts>
  call: (puts)
  drop,
  return,

label: puts
  call: <puts>
  return,

label: break
  0 ,

label: remapping
  -1 ,

label: eatLeading?
  -1 ,

label: tabAsWhitespace
  -1 ,

label: keymap
  0 ,

label: keymap:PREFIX
  9 ,

label: keymap:TABLE
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,

label: STRING-LENGTH
  256 #
  return,

label: STRING-BUFFERS
  12 #
  return,

label: tib
  memory #
  @,
  call: STRING-LENGTH
  -,
  return,

label: remapKeys
  return,

label: remap:whitespace
   dup,  127 # =if drop,  8 # then
   dup,   13 # =if drop, 10 # then
   remapping # @, 0;, drop,
   dup,   10 # =if drop, 32 # then
   tabAsWhitespace # @, 0;, drop, dup, 9 # =if drop, 32 # then
   return,

label: getc:unfiltered
   1 # 1 # out,
   call: wait
   1 # in,
   return,

label: getc:with/remap
  REPEAT
    call: getc:unfiltered
    call: remapKeys
    dup, 0 # !if call: remap:whitespace return, then
    drop,
  AGAIN
  return,

label: keymap:handler
  return,

label: getc
  REPEAT
    call: getc:unfiltered
    call: keymap:handler
    call: remapKeys
    dup,
    0 #
    !if
      call: remap:whitespace
      return,
    then
    drop,
  AGAIN
  return,


label: putc?
  dup,
  8 # =if drop, break # @, return, then dup, call: putc return,

label: eat
   eatLeading? # @, 0;, drop,
   REPEAT
     call: getc
     call: putc?
     dup,
     break # @,
     !if swap, call: !+ return, then
     drop,
  AGAIN
  return,

label: guard?
  dup,
  1+,
  call: tib
  <if drop, call: tib return, then 8 # call: putc
  return,

label: (accept)
  REPEAT
    call: getc
    dup, 8 # =if drop, 1-, call: guard? jump: (accept) then
    dup,
    call: putc
    dup, break # @, =if drop, return, then
    swap,
    call: !+
  AGAIN
  return,

label: accept
  break # !,
  call: tib
  call: eat
  call: (accept)
  0 #
  swap,
  call: !+
  drop,
  return,

label: vector
  -1 ,

label: d->class
  1+,
  return,

label: d->xt
  1+, 1+,
  return,

label: d->doc
  3 # +,
  return,

label: d->name
  4 # +,
  return,

label: header
  push,
  call: here        ( Entry Start      )
  last # @,         ( Link to previous )
  call: comma
  last # !,         ( Set as newest    )
  .data #           ( Class = .data    )
  call: comma
  call: here
  0 #               ( XT               )
  call: comma
  0 #               ( Pointer to docstr)
  call: comma
  pop,
  call: $           ( Name             )
  call: here
  swap, !, return,  ( Patch XT to HERE )

label: create
  32 #
  call: accept
  call: tib
  call: header
  return,

label: [[
  compiler #
  call: off
  return,

label: ]]
  compiler #
  call: on
  return,

label: vector?
  vector # @,
  0;, drop,
  0 #
  call: comma
  0 #
  call: comma
  return,

label: :
  call: create
  .word #
  last #
  @,
  call: d->class
  !,
  call: ]]
  call: vector?
  return,

label: t-(
  ') #
  call: accept
  return,

label: quote       ( -a  ) ( -- runtime -------------------------------- )
  pop, 1+,         (   -a  | grab the return address, add 1, and )
  dup,             (  a-aa | dup, giving two pointers to ADDR    )
  @,               ( aa-aA | dereference one for actual target   )
  1-,              ( aa-aA | subtract 1 because ip++ in ngaro vm )
  push,            ( aA-a  | push result to do a calculated jump )
  1+, return,      (  a-a  | point to start of code, jump to end )

label: [         ( -- compile-time---------------------------- )
  ' quote #      (   -   | compile a call to quote             )
  call: comma
  call: here     (   -a  | remember where to put ADDR          )
  0 #            (  a-a  | leave a cell to hold it later       )
  call: comma
  compiler # @,  (  a-af | store current compiler state        )
  compiler #     ( af-af | turn the compiler on                )
  call: on
  return,

label: ]         ( a = placeholder for quote jump, f = old compile state  )
   call: ;;      ( af-af | compile a return from quoted code   )
   compiler # !, ( af-a  | restore compiler state              )
   call: here    (  a-aA | now we know what ADDR should be     )
   call: over !, ( aA-a  | so go replace the 00                )
   compiler # @, (  a-af | recall current compile state        )
   0 # =if       ( af-a  | are we outside of the compiler?     )
                 ( -- runtime -------------------------------- )
     1+, return,       (  a-a  | for interactive, keep ptr to start  )
                 ( -- compile-time---------------------------- )
   then drop, return,  (  a-   | inside compile mode, just discard.  )
                 (       | the call to 'quote will restore it  )
                 (       | when the containing function runs   )


label: empty return,

label: if push, swap, pop, swap, 0 # !if drop, call: do return, then swap, drop, call: do return,

label: ifTrue empty # call: if return,

label: ifFalse empty # swap, call: if return,

label: dip swap, push, call: do pop, return,

label: sip call: over do # call: dip return,

label: false 0 # return,

label: true -1 # return,

label: =  ( xy-f  ) =if jump: true  then jump: false
label: <> ( xy-f  ) !if jump: true  then jump: false
label: >= ( xy-f  ) >if jump: true  then jump: false
label: <= ( xy-f  ) <if jump: true  then jump: false
label: <  ( xy-f  ) >if jump: false then jump: true
label: >  ( xy-f  ) <if jump: false then jump: true


label: compare
   REPEAT
     dup, @, push, 1+, swap,
     dup, @, push, 1+, pop, dup, pop,
     !if drop, drop, dup, xor, return, then
   0 # 12 , ,
   drop, drop, -1 # return,

label: count
  REPEAT
    call: @+
    0;,
    drop,
  AGAIN
  return,

label: getLength
  dup,
  call: count
  1-,
  swap,
  -,
  return,

label: withLength
  dup,
  call: getLength
  return,

label: string
  pop,
  call: count
  1-,
  push,
  return,

label: keepString
  string #
  call: comma
  call: here
  swap,
  call: $
  return,

label: :devector
  0 #
  swap,
  call: !+
  0 #
  swap,
  !,
  return,

label: :is
  8 #
  swap,
  call: !+
  !,
  return,

label: atib
  memory # @,
  call: STRING-LENGTH
  2 #
  *,
  -,
  return,

label: t-"
  atib #
  tib #
  call: :is
  '" #
  call: accept
  tib #
  call: :devector
  call: atib
  return,

label: #value
  0 ,

label: num
  0 ,

label: negate?
  0 ,

label: flag
  0 ,

label: base
  10 ,

label: numbers
  "0123456789ABCDEF" $,

label: nums
  numbers #
  return,

label: @base
  base #
  @,
  return,

label: (digits)
  call: nums
  +,
  @,
  call: over
  =if
    num #
    call: on
  then
  return,

label: digits
  1-,
  REPEAT
    dup,
    push,
      call: (digits)
    pop,
    0;,
    1-,
  AGAIN
  return,

label: valid?
  call: @base
  dup,
  16 #
  <if
    call: digits
    return,
  then
  drop,
  return,

label: digit?
  num #
  call: off
  call: valid?
  drop,
  num #
  @,
  return,

label: toDigit
  '0 #
  -,
  call: @base
  16 #
  =if
    dup,
    16 #
    >if
      7 #
      -,
    then
  then
  return,

label: isNegative?
  dup,
  @,
  '- #
  =if
    negate? #
    call: on
    1+,
    return,
  then
  1 #
  negate? #
  !,
  return,

label: (convert)
  REPEAT
    dup, @, 0;, call: toDigit #value # @, call: @base *, +, #value # !, 1+,
  AGAIN return,

label: toNumber
  call: isNegative? 0 # #value # !, call: (convert) drop, #value # @, negate? # @, *, return,

label: (isnumber)
  REPEAT dup, @, 0;, call: digit? flag # @, and, flag # !, 1+, AGAIN return,

label: isNumber?
  call: isNegative? flag # call: on call: (isnumber) drop, flag # @, return,

label: boot
  copytag #
  call: puts
  32 #
  call: putc
  version #
  call: puts
  call: cr
  return,

label: query
  5 #
  out,
  call: wait
  5 # in,
  return,

label: run-on-boot
   -1  # call: query memory # !,  ( Memory Size     )
   -2  # call: query fb #     !,  ( Canvas Present? )
   -3  # call: query fw #     !,  ( Canvas Width    )
   -4  # call: query fh #     !,  ( Canvas Height   )
   -11 # call: query cw #     !,  ( Console Width   )
   -12 # call: query ch #     !,  ( Console Height  )
   call: boot return,

label: name
  0 ,

label: found
  0 ,

label: prepare
  found #
  call: off
  name #
  !,
  last #
  @,
  return,

label: done
  which #
  @,
  found #
  @,
  return,

label: match?
  dup,
  call: d->name
  name #
  @,
  call: compare
  return,

label: <search>
  REPEAT
    call: match?
    0 #
    !if
      which #
      !,
      found #
      call: on
      return,
    then
    @,
    0;,
  AGAIN
  return,

label: find
  call: prepare
  call: <search>
  call: done
  return,

label: '
  32 #
  call: accept
  call: tib
  call: find
  0 #
  !if
    call: d->xt
    @,
    return,
  then
  drop,
  0 #
  return,

label: ___
  "___" $,

label: get
  dup, @, ___ # 2 # +, !, 1+, return,

label: xt:class
  dup,
  call: d->xt
  @,
  swap,
  call: d->class
  @,
  return,

label: try
  call: tib
  call: get
  call: find
  0 #
  !if
    call: d->xt
    @,
    ___ #
    call: find
    0 #
    !if
      call: xt:class
      call: withClass
      0 #
      return,
    then
    drop,
  then
  drop,
  -1 #
  return,

label: <notFound>
  call: tib
  call: getLength
  2 #
  >if
    call: try
  then
  return,

label: notFound
  call: <notFound>
  0;,
  drop,
  call: cr
  call: tib
  call: puts
  32 #
  call: putc
  '? #
  call: putc
  call: cr
  return,

label: ok
  compiler #
  @,
  call: not
  0;,
  drop,
  call: cr
  okmsg #
  call: puts
  return,

label: build#
  call: tib
  call: toNumber
  .data #
  jump: withClass

label: number
  call: tib
  call: isNumber?
  0 #
  !if
    jump: build#
  then
  jump: notFound

label: process
  0 #
  !if
    call: xt:class
    jump: withClass
  then
  drop,
  jump: number

label: listen
  REPEAT
    call: ok
    32 #
    call: accept
    call: tib
    call: find
    call: process
  AGAIN
  return,

label: save-image
  1 #
  4 #
  out,
  call: wait
  return,

label: goodbye
  call: cr
  -9 # 5 # out,
  call: wait
  return,

label: main
  call: run-on-boot
  jump: listen


main setEntryPoint
"retroImage" saveImageAs
.s
bye




( Word Prefixes and "Not Found" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
